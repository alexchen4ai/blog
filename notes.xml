<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Alex Chen&#39;s Blog</title>
<link>https://alexchen4ai.github.io/blog/notes.html</link>
<atom:link href="https://alexchen4ai.github.io/blog/notes.xml" rel="self" type="application/rss+xml"/>
<description>Personal summaries and insights gathered from reading various research papers and articles.</description>
<generator>quarto-1.4.549</generator>
<lastBuildDate>Wed, 21 Feb 2024 08:00:00 GMT</lastBuildDate>
<item>
  <title>Mixture of expert</title>
  <dc:creator>Alex Chen</dc:creator>
  <link>https://alexchen4ai.github.io/blog/notes/Large Language Model/moe.html</link>
  <description><![CDATA[ 





<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>MoE means the mixture of expert. In this blog, we will introduce the type of MoE used in the <code>mixtral8x7B</code> model. The blog will assume that you already understand the llama2 model. Thus, we will not revisit any knowledge already inside the llama2 model. Another focus of this blog will combine the code implementation to delve into the arc of MoE.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>üìù <strong>Paper</strong>: <a href="https://arxiv.org/abs/2101.03961">Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity</a></p>
</div>
</div>
<section id="difference-from-the-llama2" class="level2">
<h2 class="anchored" data-anchor-id="difference-from-the-llama2">Difference from the llama2</h2>
<p>In causal LM, we know that the decoder model can be decomposed into multiple small parts. Let‚Äôs visit the architecture of the llama2 in the Figure&nbsp;1.</p>
<div id="fig-llama2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-llama2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://alexchen4ai.github.io/blog/images/llama2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-llama2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: The architecture of the llama2 model
</figcaption>
</figure>
</div>
<p>There are many components inside the llama2 architecure, like the attention layer, positional embedding, RMS norm, FC etc. The only difference here is the block of <strong>FF SwiGLU</strong> (<code>FF</code> is the feedforward network and the implementation is add the hidden embedding dimension first, through the activation function and finally decrease the dimension). Instead of using only one FF function, we use the mixture of expert, which export is the actually a <strong>FF</strong>. In llama2, the code implementation would be as simple as:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">class</span> LlamaMLP(nn.Module):</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, config):</span>
<span id="cb1-3">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">super</span>().<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>()</span>
<span id="cb1-4">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.config <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> config</span>
<span id="cb1-5">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> config.hidden_size</span>
<span id="cb1-6">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.intermediate_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> config.intermediate_size</span>
<span id="cb1-7">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.gate_proj <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.hidden_size, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.intermediate_size, bias<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>)</span>
<span id="cb1-8">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.up_proj <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.hidden_size, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.intermediate_size, bias<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>)</span>
<span id="cb1-9">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.down_proj <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.intermediate_size, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.hidden_size, bias<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>)</span>
<span id="cb1-10">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.act_fn <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> ACT2FN[config.hidden_act]</span>
<span id="cb1-11"></span>
<span id="cb1-12">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> forward(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x):</span>
<span id="cb1-13">        down_proj <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.down_proj(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.act_fn(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.gate_proj(x)) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.up_proj(x))</span>
<span id="cb1-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> down_proj</span></code></pre></div>
<p>OK, now we will add more complexity to this function. ::: {.callout-tip} Note that all other parts are the same except the feedforward block. :::</p>
</section>
<section id="mathematical-insights" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-insights">Mathematical insights</h2>
<p>The FF model is actually the expert! For the llama2 model, we only have one expert, therefore, in the case of llama2, we have</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ay%20=%20E(x),%0A"></p>
<p>where <img src="https://latex.codecogs.com/png.latex?x,%20y"> are the value before and after the FF block. In the MoE, we actually prepare multiple trainable experts, so there are multiple <code>E</code> layers. A gating network is thus introduced to decide which network should be used. And now the expression becomes:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ay%20=%20%5Csum_%7Bi=1%7D%5En%20G(x)_i%20E_i(x).%0A"></p>
<p>It is special to choose the network <code>G</code>. Here, we just introduce the found research work from the paper <a href="https://arxiv.org/abs/2101.03961">Switch Transformer</a> which is also the famous <a href="https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1">Mixtral-8x7B</a>.</p>
<p>Specially for this model, <code>n=8</code>. Suppose the last dimension of <code>x</code> is <code>d</code>, we will include the dimension of each variables for following up explanation.</p>
<p>The steps to construct the <code>G(x)</code> are:</p>
<ol type="1">
<li>Set trainable linear layer <img src="https://latex.codecogs.com/png.latex?W_g"> of size <code>d*n</code>. <img src="https://latex.codecogs.com/png.latex?%0AH(x)=%20x%20%5Ccdot%20W_%7B%5Cmathrm%7Bg%7D%7D%0A"> and we know the dimension of <img src="https://latex.codecogs.com/png.latex?H(x)"> is <img src="https://latex.codecogs.com/png.latex?n=8">.</li>
<li>Only pick the top K experts: <img src="https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7BKeepTopK%7D(v,%20k)_i=%20%5Cbegin%7Bcases%7Dv_i%20&amp;%20%5Ctext%20%7B%20if%20%7D%20v_i%20%5Ctext%20%7B%20is%20in%20the%20top%20%7D%20k%20%5Ctext%20%7B%20elements%20of%20%7D%20v%20%5C%5C%20-%5Cinfty%20&amp;%20%5Ctext%20%7B%20otherwise.%20%7D%5Cend%7Bcases%7D%0A"></li>
<li>Apply the softmax to get the final <code>G(x)</code> <img src="https://latex.codecogs.com/png.latex?%0AG(x)=%5Coperatorname%7BNorm%7D(%5Coperatorname%7BSoftmax%7D(%5Coperatorname%7BKeepTopK%7D(H(x),%20k)))%0A"></li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Set to <img src="https://latex.codecogs.com/png.latex?-%5Cinfty"> so that it becomes zero during softmax. Thus, for the final output, we only have <img src="https://latex.codecogs.com/png.latex?k"> experts which are really used.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>For different batch of tokens, they will choose different experts! For example the <code>batch[0]</code> will choose the expert 0 and 3, while the <code>batch[1]</code> will choose the expert 4 and 7.</p>
</div>
</div>
</section>
<section id="load-balancing-loss" class="level2">
<h2 class="anchored" data-anchor-id="load-balancing-loss">Load balancing loss</h2>
<p>Since different portion of total tokens will enter different experts, like the unbalanced dataset problem, we need to add a load balancing loss. Given <img src="https://latex.codecogs.com/png.latex?N"> experts indexed by <img src="https://latex.codecogs.com/png.latex?i=1"> to <img src="https://latex.codecogs.com/png.latex?N"> and a batch <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BB%7D"> with <img src="https://latex.codecogs.com/png.latex?T"> tokens, the auxiliary loss is computed as the scaled dot-product between vectors <img src="https://latex.codecogs.com/png.latex?f"> and <img src="https://latex.codecogs.com/png.latex?P">, <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%20%7B%20loss%20%7D=%5Calpha%20%5Ccdot%20N%20%5Ccdot%20%5Csum_%7Bi=1%7D%5EN%20f_i%20%5Ccdot%20P_i%0A"> where <img src="https://latex.codecogs.com/png.latex?f_i"> is the fraction of tokens dispatched to expert <img src="https://latex.codecogs.com/png.latex?i">, <img src="https://latex.codecogs.com/png.latex?%0Af_i=%5Cfrac%7B1%7D%7BT%7D%20%5Csum_%7Bx%20%5Cin%20%5Cmathcal%7BB%7D%7D%20%5Cmathbb%7B1%7D%5C%7B%5Coperatorname%7Bargmax%7D%20p(x)=i%5C%7D%0A"> and <img src="https://latex.codecogs.com/png.latex?P_i"> is the fraction of the router probability allocated for expert <img src="https://latex.codecogs.com/png.latex?i,%7B%20%7D%5E2"> <img src="https://latex.codecogs.com/png.latex?%0AP_i=%5Cfrac%7B1%7D%7BT%7D%20%5Csum_%7Bx%20%5Cin%20%5Cmathcal%7BB%7D%7D%20p_i(x)%0A"></p>
<p>We add this loss since we want to encourages uniform routing since the loss is minimized when <img src="https://latex.codecogs.com/png.latex?%0Af_i%20=%20P_i%20=%20%5Cfrac%7B1%7D%7BN%7D.%0A"></p>


</section>

 ]]></description>
  <category>Large Language Models</category>
  <guid>https://alexchen4ai.github.io/blog/notes/Large Language Model/moe.html</guid>
  <pubDate>Wed, 21 Feb 2024 08:00:00 GMT</pubDate>
</item>
<item>
  <title>Scalable diffusion models with transformers</title>
  <dc:creator>Alex Chen</dc:creator>
  <link>https://alexchen4ai.github.io/blog/notes/Diffusion Model/sd.html</link>
  <description><![CDATA[ 





<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>A text to image generation model from the diffusion architecture.</p>
</div>
</div>
<p>üìù <strong>Paper</strong>: <a href="https://arxiv.org/abs/2212.09748">https://arxiv.org/abs/2212.09748</a></p>



 ]]></description>
  <category>Diffusion Model</category>
  <guid>https://alexchen4ai.github.io/blog/notes/Diffusion Model/sd.html</guid>
  <pubDate>Mon, 19 Feb 2024 08:00:00 GMT</pubDate>
</item>
<item>
  <title>Reinforcement learning for large language model</title>
  <dc:creator>Alex Chen</dc:creator>
  <link>https://alexchen4ai.github.io/blog/notes/Large Language Model/rl_llm.html</link>
  <description><![CDATA[ 





<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Reinforment is a common technique, which can be applied to the large language model area.</p>
</div>
</div>
<section id="background-of-reinforcement-learning" class="level2">
<h2 class="anchored" data-anchor-id="background-of-reinforcement-learning">Background of reinforcement learning</h2>
In the first section, we will review the fundamental concept of the reinforcement learning. The fundamental part of the reinforcement learning includes the <strong>agent</strong> and <strong>environment</strong>. The process is as the following:
<p align="center">
<img src="https://alexchen4ai.github.io/blog/images/RL_basic.png" width="60%">
</p>
<p>At each iteration step, we have the state of the environement marked as <img src="https://latex.codecogs.com/png.latex?S">, the action <img src="https://latex.codecogs.com/png.latex?A"> and the reward <img src="https://latex.codecogs.com/png.latex?R">. Below, we list the step at the time step <img src="https://latex.codecogs.com/png.latex?t">:</p>
<ol type="1">
<li>Based on the current state <img src="https://latex.codecogs.com/png.latex?S_t">, the agent make the action <img src="https://latex.codecogs.com/png.latex?A_t">;</li>
<li>The environment react to the action and transit to the state <img src="https://latex.codecogs.com/png.latex?S_%7Bt+1%7D"> and reward <img src="https://latex.codecogs.com/png.latex?R_%7Bt+1%7D">.</li>
</ol>
<p>Therefore, related to each action, we will have a state of <img src="https://latex.codecogs.com/png.latex?S_t,%20A_t,%20S_%7Bt+1%7D,%20R_%7Bt+1%7D">. And these four variables will be the critical data used for the reinforcement learning! Now, let me introduce more about the <strong>glossary</strong> of the reinforcement learning terms.</p>
<ul>
<li><em>Markov chain</em>: The Markov chain means that the action taken by the agent is only dependent on the most recent state/present state, and is independent of past states.</li>
<li><em>Observation/State</em>: The state is the complete description while the observation is just the partial description. The partial description means part of the state.</li>
<li><em>policy</em>: The policy is usually denoted as <img src="https://latex.codecogs.com/png.latex?%5Cpi"> and it is used to decide which action <img src="https://latex.codecogs.com/png.latex?a"> to take. According to the Markov chain, we have <img src="https://latex.codecogs.com/png.latex?%5Cpi(s)=a">.</li>
<li><em>reward</em>: Reward is the value that we can get immediately after we take a new action. For example, in cartpole example, we get every positive feedback if the cartpole doesn‚Äôt fail.</li>
<li><em>Value</em>: The value function to calculate the discounted sum of all future rewards! Thus, the values are different from the reward.</li>
</ul>
<p>These are some basic concepts in the reinforcement learning! We will introduce more advanced concept along with more topics involved below. We revisit the fundamental part of the RL: The agent can repeated to take actions and get feedback (rewards/values) from the environment so that it can update the agent itself to behave better to get best reward or values. The deep learning and pytorch is not designed for the RL, and RL is more a mathematically which may not naturally suited for the deep learning. Rather, we design some equation to apply the deep learning. Thus, when we design the RL, we need to think from the fundamental math, and deep learning is just a method to solve a math problem.</p>
</section>
<section id="the-classification-of-rl" class="level2">
<h2 class="anchored" data-anchor-id="the-classification-of-rl">The classification of RL</h2>
<p>To solve the RL problem, we have various methods! The detailed is concluded in the figure below. We will study more about the policy based method, the value based method. And for SOTA, the LLM usuaully use a combined method. When we consider how to train the RL, we should first think about how to use the pretrained model. We wish the model to guide us to get the best action to take at every step! Thus, we need a great policy <img src="https://latex.codecogs.com/png.latex?%5Cpi%5E*">!.</p>
<p align="center">
<img src="https://alexchen4ai.github.io/blog/images/RL_classification.png" width="100%">
</p>
<section id="the-value-based-method" class="level3">
<h3 class="anchored" data-anchor-id="the-value-based-method">The value based method</h3>
<p>The famous <img src="https://latex.codecogs.com/png.latex?Q"> learning is a typical value-based method. The original paper can be accessed <a href="https://link.springer.com/content/pdf/10.1007/BF00992698.pdf"><strong>here</strong></a>. The <img src="https://latex.codecogs.com/png.latex?Q"> is the abbreviate of <em>quality</em>. The value based method has two submethods called the state-value function and the action-value function. Usually, we use <img src="https://latex.codecogs.com/png.latex?V"> to represent the value, which is</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AV_%7B%5Cpi%7D(s)%20=%20%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5Cleft%5B%20R_%7Bt+1%7D+%5Cgamma%20R_%7Bt+2%7D%20+%20%5Cgamma%5E2R_%7Bt+3%7D+...%20%7C%20S_t=s%20%5Cright%5D%0A"></p>
<p>Let me clarify the equation above in a probability. The <img src="https://latex.codecogs.com/png.latex?%5Cpi"> is like a distribution, and we may express the value as</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AV_%7B%5Cpi%7D(s)%20=%20%5Cmathbb%7BE%7D_%7B%5Ctau%5Csim%5Cpi%7D%5Cleft%5B%20R_%7Bt+1%7D+%5Cgamma%20R_%7Bt+2%7D%20+%20%5Cgamma%5E2R_%7Bt+3%7D+...%20%7C%20S_t=s%20%5Cright%5D%0A"></p>
<p>since we have <img src="https://latex.codecogs.com/png.latex?a%5Csim%20%5Cpi(s)">. And <img src="https://latex.codecogs.com/png.latex?a"> is directly relevant to the trajectory <img src="https://latex.codecogs.com/png.latex?%5Ctau"> which can be used for comprehensive rewards. Now, we have known the value function, this is a value that can evaluate the current confidence to get the best reward based on the current state! Another better and granular method is not just the current state, but also the action. And we introduce the <img src="https://latex.codecogs.com/png.latex?Q"> value. However, fundamentally, we have <img src="https://latex.codecogs.com/png.latex?Q"> and <img src="https://latex.codecogs.com/png.latex?V"> to express the same meaning, the confidence or the estimated quality of the current condition. The only difference is that the <img src="https://latex.codecogs.com/png.latex?Q"> function also count in the actions.</p>
<p>The comparison would be <img src="https://latex.codecogs.com/png.latex?V_%5Cpi%20(s)=%5Cmathbb%7BE%7D_%5Cpi%20%5BG_t%7CS_t=s%5D"> vs.&nbsp;<img src="https://latex.codecogs.com/png.latex?Q_%7B%5Cpi%7D(s,%20a)=%5Cmathbb%7BE_%5Cpi%7D%5BG_t%7CS_t=s,%20A_t=a%5D">. The <img src="https://latex.codecogs.com/png.latex?G_t"> here represent the ending state. Then, as stated above how do we get the best policy? We can use</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cpi%5E*%20=%20%5Ctext%7Barg%7D%5Cmax_a%20Q%5E*(s,%20a)%0A"></p>
<p>To simulate the RL, we usually need to simulate the whole episode, like a cartpole example would continue until it fails. However, there are ways to simplify the process by <strong>Bellman equation</strong>: <img src="https://latex.codecogs.com/png.latex?%0AV_%5Cpi(s)%20=%20%5Cmathbb%7BE%7D_%7B%5Cpi%7D%20%5BR_%7Bt+1%7D+%5Cgamma%20*%20V_%7B%5Cpi%7D(S_%7Bt+1%7D)%7CS_t=s%5D.%0A"> And we can update the value function by <strong>Monte Carlo</strong> or the <strong>Temporary Difference</strong> method. The <img src="https://latex.codecogs.com/png.latex?Q"> learning is an off-policy (when updating the value function choose a different way to sample the action) value-based method that uses a TD approach to train its action-value function.</p>
<p>Before move on, we explain the off-policy. In RL, we usually use <img src="https://latex.codecogs.com/png.latex?%5Cepsilon"> greedy policy to choose the actions. That is for a given state <img src="https://latex.codecogs.com/png.latex?s">, we take the action by sample <img src="https://latex.codecogs.com/png.latex?p%5Cin%20%5B0,1%5D">: <img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%0A%5Cbegin%7Bcases%7D%0A%5Cpi%5E*(s)%20&amp;%20%5Ctext%7B$p%5Cleq%5Cepsilon$%7D,%20%5C%5C%0A%5Ctext%7Brandom%20action%7D%20&amp;%20%5Ctext%7Botherwise%7D.%0A%5Cend%7Bcases%7D%0A"> This is a combination of exploration and eploitation. And each time, when we train the <img src="https://latex.codecogs.com/png.latex?Q"> function, we update it like <span id="eq-q-update"><img src="https://latex.codecogs.com/png.latex?%0AQ(S_t,%20A_t)%20%5Cleftarrow%20Q(S_t,%20A_t)%20+%5Calpha%20(R_%7Bt+1%7D+%5Cgamma%20%5Cmax_a%20Q(S_%7Bt+1%7D,%20a)%20-Q(S_t,%20A_t))%0A%5Ctag%7B1%7D"></span></p>
<p>For certain case with finite number of state and actions, we can easily use a table to record the <img src="https://latex.codecogs.com/png.latex?Q"> function. However, for some infinite number of states and actions, we need more complicated expression. For example, a math function, and abstract that function we can get the deep neural network <img src="https://latex.codecogs.com/png.latex?Q">. This is how we can infer the <a href="https://www.nature.com/articles/nature14236">DQN, a nature paper</a>. This basically tell us the value of <img src="https://latex.codecogs.com/png.latex?Q_%5Ctheta%20(s,%20a)">.</p>
<p>A DQN algorithm is:</p>
<ol type="1">
<li>Initialize replay memory <img src="https://latex.codecogs.com/png.latex?D"> to capacity <img src="https://latex.codecogs.com/png.latex?N"></li>
<li>Initialize action-value function <img src="https://latex.codecogs.com/png.latex?Q"> with random weights <img src="https://latex.codecogs.com/png.latex?%5Ctheta"></li>
<li>Initialize target action-value function <img src="https://latex.codecogs.com/png.latex?%5Chat%7BQ%7D"> with weights <img src="https://latex.codecogs.com/png.latex?%5Ctheta%5E%7B-%7D%20=%20%5Ctheta"></li>
<li>For episode = <img src="https://latex.codecogs.com/png.latex?1,%20M"> do
<ul>
<li>Initialize sequence <img src="https://latex.codecogs.com/png.latex?s_1%20=%20%5C%7Bx_1%5C%7D"> and preprocessed sequence <img src="https://latex.codecogs.com/png.latex?%5Cphi_1%20=%20%5Cphi(s_1)"></li>
<li>For <img src="https://latex.codecogs.com/png.latex?t%20=%201,%20T"> do
<ul>
<li>With probability <img src="https://latex.codecogs.com/png.latex?%5Cvarepsilon"> select a random action <img src="https://latex.codecogs.com/png.latex?a_t"> otherwise select <img src="https://latex.codecogs.com/png.latex?a_t%20=%20%5Ctext%7Bargmax%7D_a%20Q(%5Cphi(s_t),%20a;%20%5Ctheta)"></li>
<li>Execute action <img src="https://latex.codecogs.com/png.latex?a_t"> in emulator and observe reward <img src="https://latex.codecogs.com/png.latex?r_t"> and image <img src="https://latex.codecogs.com/png.latex?x_%7Bt+1%7D"></li>
<li>Set <img src="https://latex.codecogs.com/png.latex?s_%7Bt+1%7D%20=%20s_t,%20a_t,%20x_%7Bt+1%7D"> and preprocess <img src="https://latex.codecogs.com/png.latex?%5Cphi_%7Bt+1%7D%20=%20%5Cphi(s_%7Bt+1%7D)"></li>
<li>Store transition <img src="https://latex.codecogs.com/png.latex?(%5Cphi_t,%20a_t,%20r_t,%20%5Cphi_%7Bt+1%7D)"> in <img src="https://latex.codecogs.com/png.latex?D"></li>
<li>Sample random minibatch of transitions <img src="https://latex.codecogs.com/png.latex?(%5Cphi_j,%20a_j,%20r_j,%20%5Cphi_%7Bj+1%7D)"> from <img src="https://latex.codecogs.com/png.latex?D"></li>
<li>Set <img src="https://latex.codecogs.com/png.latex?y_j%20=%20%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%0Ar_j%20&amp;%20%5Ctext%7Bif%20episode%20terminates%20at%20step%20%7D%20j+1%20%5C%5C%0Ar_j%20+%20%5Cgamma%20%5Cmax_%7Ba'%7D%20%5Chat%7BQ%7D(%5Cphi_%7Bj+1%7D,%20a';%20%5Ctheta%5E%7B-%7D)%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Barray%7D%5Cright."></li>
<li>Perform a gradient descent step on <img src="https://latex.codecogs.com/png.latex?(y_j%20-%20Q(%5Cphi_j,%20a_j;%20%5Ctheta))%5E2"> with respect to the network parameters <img src="https://latex.codecogs.com/png.latex?%5Ctheta"></li>
<li>Every <img src="https://latex.codecogs.com/png.latex?C"> steps reset <img src="https://latex.codecogs.com/png.latex?%5Chat%7BQ%7D%20=%20Q"></li>
</ul></li>
</ul></li>
</ol>
<p>Here <img src="https://latex.codecogs.com/png.latex?%5Cphi"> represent some feature encoder! For example, if the state can be represented as image. Then, <img src="https://latex.codecogs.com/png.latex?%5Cphi"> is something like the RGB value extractor. From the DQN algorithm above, we notice that the gradient descent is applied on the loss term of <span id="eq-mse"><img src="https://latex.codecogs.com/png.latex?%0A(y_j%20-%20Q(%5Cphi_j,%20a_j;%20%5Ctheta))%5E2%0A%5Ctag%7B2%7D"></span></p>
<p>This is to make the learned <img src="https://latex.codecogs.com/png.latex?Q"> function to approximate the value of the predicted <img src="https://latex.codecogs.com/png.latex?Q"> value. If we revisit the Equation&nbsp;1, we notice that the original Q value update is to directly update the <img src="https://latex.codecogs.com/png.latex?Q(S_t,%20A_t)">, and the goal is to reduce the difference between <img src="https://latex.codecogs.com/png.latex?R_%7Bt+1%7D+%5Cgamma%20%5Cmax_a%20Q(S_%7Bt+1%7D,%20a)"> and the <img src="https://latex.codecogs.com/png.latex?Q(S_t,%20A_t)">. In the context of the DQN, we can direcly construct the Equation&nbsp;2 for it! One notation here is that in the Equation&nbsp;1, we set the <img src="https://latex.codecogs.com/png.latex?R_%7Bt+1%7D">, with the same subscript as <img src="https://latex.codecogs.com/png.latex?S_%7Bt+1%7D">, but in the algorithm described above, we have it expressed as <img src="https://latex.codecogs.com/png.latex?r_%7Bj%7D"> with the <code>-1</code> subscript compared to <img src="https://latex.codecogs.com/png.latex?%5Cphi_%7Bj+1%7D">. However, the two terms are the same, we use <img src="https://latex.codecogs.com/png.latex?t"> since it represents the time step. For the use of <img src="https://latex.codecogs.com/png.latex?j">, it is one step of generated rewards! It is just different notation.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Why do we use Equation&nbsp;2? Q is the quality value, and it is used to estimate the total expected rewards based on the current state and the action. Suppose we already have the best <img src="https://latex.codecogs.com/png.latex?Q">, then <img src="https://latex.codecogs.com/png.latex?Q(%5Cphi_j,%20a_j)"> should be equal to the reward after we take the action <img src="https://latex.codecogs.com/png.latex?a_j">, and then based on the state <img src="https://latex.codecogs.com/png.latex?%5Cphi_%7Bj+1%7D">, the best rewards we can expect, and we use a greedy algorithm here.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>It is always good to visit the code implementation to make sure you understand the detail.</p>
</div>
</div>
<p>We can study a <a href="https://huggingface.co/learn/deep-rl-course/en/unit3/deep-q-algorithm">DQN example from the atari simulation</a>, and the full github code can be accessed there. Now, we will combine the algorithm and the code to introduce more about the DQN.</p>
<p>Firstly, we need to have data generation process, and we can use</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1">next_obs, rewards, terminations, truncations, infos <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> envs.step(actions)</span></code></pre></div>
<p>to get the variables <img src="https://latex.codecogs.com/png.latex?R,%20S,%20A"> and so on. And we save the generated data to the replay</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1">rb.add(obs, real_next_obs, actions, rewards, terminations, infos)</span></code></pre></div>
<p>And the update process is like</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> rb.sample(args.batch_size)</span>
<span id="cb3-2"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">with</span> torch.no_grad():</span>
<span id="cb3-3">   target_max, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> target_network(data.next_observations).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(dim<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb3-4">   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># data.dones is 0 or 1.</span></span>
<span id="cb3-5">   td_target <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> data.rewards.flatten() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> args.gamma <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> target_max <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> data.dones.flatten())</span>
<span id="cb3-6">old_val <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> q_network(data.observations).gather(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, data.actions).squeeze()</span>
<span id="cb3-7">loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> F.mse_loss(td_target, old_val)</span></code></pre></div>
</section>
<section id="the-policy-based-method" class="level3">
<h3 class="anchored" data-anchor-id="the-policy-based-method">The policy based method</h3>
<p>We can also train the policy directly <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta">. It is more intuitive. Compared to the value-based method, it has pros and cons.</p>
<p>For pros: (a) Can explore stochastic polify, no need for the exploration and exploitation effort; (b) More effective in high-dimensional action space, especially the continuous actions spaces; (c) Better convergence properties, the curve is smoother.</p>
<p>For the cons: (a) Often get suboptimal result; (b) Take longer time to train; (c) Policy gradient have high variance (<strong>The policy gradient in different step has really different result</strong>).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that Q learning method needs the <code>argmax</code> to get the best action. And if the action is a continuous space, we need to do some pretty complicated optimization to get the result!</p>
</div>
</div>
<p>Note that <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta%20(s)%20=%20%5Cmathbb%7BP%7D(A%7Cs;%5Ctheta)">. Thus, the training basically becomes that when we have postive reward, we should increase the proability of the state and action pair. Otherwise, decrease it. The objective function is still the total rewards! <img src="https://latex.codecogs.com/png.latex?%0AJ(%5Ctheta)%20=%20%5Cmathbb%7BE%7D_%7B%5Ctau%5Csim%20%5Cpi%7D%5BR(%5Ctau)%5D,%0A"> where <img src="https://latex.codecogs.com/png.latex?%5Ctau"> is a trajectory (a whole simulation process). We already have a theorem to update the policy:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cnabla_%5Ctheta%20J(%5Ctheta)=%5Cmathbb%7BE%7D_%7B%5Cpi_%5Ctheta%7D%5Cleft%5B%5Cnabla_%5Ctheta%20%5Clog%20%5Cpi_%5Ctheta%5Cleft(a_t%20%5Cmid%20s_t%5Cright)%20R(%5Ctau)%5Cright%5D%0A"></p>
<p>which is valid for any differentiable policy and for any policy objective function! To better understand the process, we introduce the <strong>Monte Carlo Reinforce</strong>. In a loop:</p>
<ul>
<li>Use the policy <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta"> to collect an episode <img src="https://latex.codecogs.com/png.latex?%5Ctau"></li>
<li>Use the episode to estimate the gradient <img src="https://latex.codecogs.com/png.latex?%5Chat%7Bg%7D=%5Cnabla_%5Ctheta%20J(%5Ctheta)"> <img src="https://latex.codecogs.com/png.latex?%0A%5Cnabla_%5Ctheta%20J(%5Ctheta)%20%5Capprox%20%5Chat%7Bg%7D=%5Csum_%7Bt=0%7D%20%5Cnabla_%5Ctheta%20%5Clog%20%5Cpi_%5Ctheta%5Cleft(a_t%20%5Cmid%20s_t%5Cright)%20R(%5Ctau)%0A"></li>
<li>Update the weights of the policy: <img src="https://latex.codecogs.com/png.latex?%5Ctheta%20%5Cleftarrow%20%5Ctheta+%5Calpha%20%5Chat%7Bg%7D">. (Gradient ascent)</li>
</ul>
<p>Alternatively, we can collect multiple trajectories (helpful to mitigate the variance), and the gradient becomes <img src="https://latex.codecogs.com/png.latex?%0A%5Cnabla_%5Ctheta%20J(%5Ctheta)%20%5Capprox%20%5Chat%7Bg%7D=%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5Em%5Csum_%7Bt=0%7D%20%5Cnabla_%5Ctheta%20%5Clog%20%5Cpi_%5Ctheta%5Cleft(a_t%5E%7B(i)%7D%20%5Cmid%20s_t%5E%7B(i)%7D%5Cright)%20R(%5Ctau%5E%7B(i)%7D).%0A"></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>We can treat the <img src="https://latex.codecogs.com/png.latex?%5Cnabla_%5Ctheta%20%5Clog%5Cpi_%5Ctheta(a_t%5Cmid%20s_t)"> is the direction of the steeppest increase of the log probability of selected action based on the <img src="https://latex.codecogs.com/png.latex?s_t">. This is because that we wish to maximize the objective here (rewards).</p>
</div>
</div>
<p>For the derivation of the policy gradient theorem, check the following:</p>
<div id="thm-policy-gradient-theorem" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (policy-gradient-theorem)</strong></span> The derivation of the policy gradient theorem is as the following:</p>
<p><span id="eq-policy"><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cnabla_%5Ctheta%20J(%5Ctheta)%20%20&amp;=%20%5Cmathbb%7BE%7D_%7B%5Ctau%5Csim%20%5Cpi%7D%5BR(%5Ctau)%5D%20%5C%5C%0A%20%20%20&amp;=%20%5Cnabla_%5Ctheta%20%5Csum_%7B%5Ctau%7DP(%5Ctau;%5Ctheta)R(%5Ctau)%20%5C%5C%0A%20%20%20&amp;=%20%5Csum_%7B%5Ctau%7D%20%5Cnabla_%5Ctheta%20P(%5Ctau;%5Ctheta)R(%5Ctau)%20%5C%5C%0A%20%20%20&amp;=%20%5Csum_%7B%5Ctau%7D%20P(%5Ctau;%5Ctheta)%20%5Cfrac%7B%5Cnabla_%5Ctheta%20P(%5Ctau;%5Ctheta)%7D%7BP(%5Ctau;%5Ctheta)%7DR(%5Ctau)%20%5C%5C%0A%20%20%20&amp;=%20%5Csum_%7B%5Ctau%7D%20P(%5Ctau;%5Ctheta)%20%5Cnabla_%5Ctheta%20%5Clog%20P(%5Ctau;%5Ctheta)R(%5Ctau)%20%5C%5C%0A%20%20%20&amp;=%20%5Csum_%7B%5Ctau%7D%20P(%5Ctau;%5Ctheta)%20%5Cnabla_%5Ctheta%5Clog%20%5B%5Cphi(s_0)%5Cprod_%7Bt=0%7D%5ET%20P(s_%7Bt+1%7D%7Cs_t,%20a_t)%5Cpi_%5Ctheta%20(a_t%5Cmid%20s_t)%5D%20R(%5Ctau)%5C%5C%0A%20%20%20&amp;=%20%5Csum_%7B%5Ctau%7D%20P(%5Ctau;%5Ctheta)%20%5Cnabla_%5Ctheta%5Cleft%5B%5Clog%5Cphi(s_0)%20+%20%5Clog%5Csum_%7Bt=0%7D%5ET%20P(s_%7Bt+1%7D%7Cs_t,%20a_t)%20+%5Clog%5Csum_%7Bt=0%7D%5ET%5Cpi_%5Ctheta%20(a_t%5Cmid%20s_t)%5Cright%5D%20R(%5Ctau)%5C%5C%0A%20%20%20&amp;=%20%5Csum_%7B%5Ctau%7D%20P(%5Ctau;%5Ctheta)%20%5Cnabla_%5Ctheta%5Cleft%5B%5Clog%5Csum_%7Bt=0%7D%5ET%5Cpi_%5Ctheta%20(a_t%5Cmid%20s_t)%5Cright%5D%20R(%5Ctau).%0A%5Cend%7Baligned%7D%0A%5Ctag%7B3%7D"></span></p>
</div>
<p>For the code part, using the cartpole as an example, the policy framework would be</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">class</span> Policy(nn.Module):</span>
<span id="cb4-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, s_size, a_size, h_size):</span>
<span id="cb4-3">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">super</span>(Policy, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>).<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>()</span>
<span id="cb4-4">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(s_size, h_size)</span>
<span id="cb4-5">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(h_size, a_size)</span>
<span id="cb4-6"></span>
<span id="cb4-7">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> forward(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x):</span>
<span id="cb4-8">        x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> F.relu(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc1(x))</span>
<span id="cb4-9">        x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc2(x)</span>
<span id="cb4-10">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> F.softmax(x, dim<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb4-11"></span>
<span id="cb4-12">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> act(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, state):</span>
<span id="cb4-13">        state <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.from_numpy(state).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>().unsqueeze(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>).to(device)</span>
<span id="cb4-14">        probs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.forward(state).cpu()</span>
<span id="cb4-15">        m <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Categorical(probs)</span>
<span id="cb4-16">        action <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.argmax(m)</span>
<span id="cb4-17">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> action.item(), m.log_prob(action)</span></code></pre></div>
<p>Note that we need to use the <code>Categorical</code> from <code>torch.distributions</code> to enable the backpropagation. The reinforce process can be constructed according to the reinfoce algorithm introduced above.</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> reinforce(policy, optimizer, n_training_episodes, max_t, gamma, print_every):</span>
<span id="cb5-2">    scores_deque <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> deque(maxlen<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>)</span>
<span id="cb5-3">    scores <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb5-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i_episode <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, n_training_episodes <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb5-5">        saved_log_probs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb5-6">        rewards <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb5-7">        state <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> env.reset()</span>
<span id="cb5-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> t <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(max_t):</span>
<span id="cb5-9">            action, log_prob <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> policy.act(state)</span>
<span id="cb5-10">            saved_log_probs.append(log_prob)</span>
<span id="cb5-11">            state, reward, done, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> env.step(action)</span>
<span id="cb5-12">            rewards.append(reward)</span>
<span id="cb5-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> done:</span>
<span id="cb5-14">                <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">break</span></span>
<span id="cb5-15">        scores_deque.append(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>(rewards))</span>
<span id="cb5-16">        scores.append(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>(rewards))</span>
<span id="cb5-17"></span>
<span id="cb5-18">        returns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> deque(maxlen<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>max_t)</span>
<span id="cb5-19">        n_steps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(rewards)</span>
<span id="cb5-20">        </span>
<span id="cb5-21">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> t <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n_steps)[::<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]:</span>
<span id="cb5-22">            disc_return_t <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> returns[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(returns) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">else</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb5-23">            returns.appendleft(gamma <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> disc_return_t <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> rewards[t])</span>
<span id="cb5-24"></span>
<span id="cb5-25">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">## standardization of the returns is employed to make training more stable</span></span>
<span id="cb5-26">        eps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.finfo(np.float32).eps.item()</span>
<span id="cb5-27"></span>
<span id="cb5-28">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">## eps is the smallest representable float, which is</span></span>
<span id="cb5-29">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># added to the standard deviation of the returns to avoid numerical instabilities</span></span>
<span id="cb5-30">        returns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(returns)</span>
<span id="cb5-31">        returns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (returns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> returns.mean()) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (returns.std() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> eps)</span>
<span id="cb5-32"></span>
<span id="cb5-33">        policy_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb5-34">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> log_prob, disc_return <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">zip</span>(saved_log_probs, returns):</span>
<span id="cb5-35">            policy_loss.append(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>log_prob <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> disc_return)</span>
<span id="cb5-36">        policy_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.cat(policy_loss).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>()</span>
<span id="cb5-37"></span>
<span id="cb5-38">        optimizer.zero_grad()</span>
<span id="cb5-39">        policy_loss.backward()</span>
<span id="cb5-40">        optimizer.step()</span>
<span id="cb5-41"></span>
<span id="cb5-42">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> i_episode <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> print_every <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb5-43">            <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Episode </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{}</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\t</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Average Score: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{:.2f}</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">format</span>(i_episode, np.mean(scores_deque)))</span>
<span id="cb5-44">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> scores</span></code></pre></div>
</section>
<section id="the-actor-critic-method-and-ppo" class="level3">
<h3 class="anchored" data-anchor-id="the-actor-critic-method-and-ppo">The actor-critic method and PPO</h3>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>SOTA, we usually use a mixed method containing both policy based and value based methods.</p>
</div>
</div>
<p>The motivation of the actor-critic method is to lower the variation of the policy method. We can use a large number of the trajectories but it is not efficient. Therefore, we choose a new method called actor-critic method. That is to say, instead of giving rewards/feedback to the policy (actor) after many trajectories, we can use critic to give instant feedback to evaluate the actions taken by the policy. Now, we have two network to train:</p>
<ul>
<li>A policy function with parameters <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta(s)">;</li>
<li>A value function with parameters <img src="https://latex.codecogs.com/png.latex?%7Bq%7D_w(s,%20a)"></li>
</ul>
<p>This is a combined methods of the policy-based and value-based methods. For one step of time <img src="https://latex.codecogs.com/png.latex?t"></p>
<ol type="1">
<li>At time step <img src="https://latex.codecogs.com/png.latex?t">, we have the state <img src="https://latex.codecogs.com/png.latex?s_t">;</li>
<li>We have the policy <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta(s_t)%20=%20a_t">;</li>
<li>Now, we can compute the Q-value by the value function directly as <img src="https://latex.codecogs.com/png.latex?Q_t=%7Bq%7D_w(s,%20a)">;</li>
<li>Execute the action <img src="https://latex.codecogs.com/png.latex?a_t"> and get the new state <img src="https://latex.codecogs.com/png.latex?s_%7Bt+1%7D"> and new reward <img src="https://latex.codecogs.com/png.latex?r_%7Bt+1%7D">.</li>
<li>Update the policy parameters using the Q value;</li>
<li>Using the updated parameters to get the next action <img src="https://latex.codecogs.com/png.latex?a_%7Bt+1%7D">, and use the new action to update critic parameters.</li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In policy based function, Equation&nbsp;3 needs to use <img src="https://latex.codecogs.com/png.latex?R(%5Ctau)">, and <img src="https://latex.codecogs.com/png.latex?R(%5Ctau)"> is obtained by iterative experiments. Now, we can use Q value since they represent the same meaning. Also, when we update the Q parameters, we use <code>argmax</code> to get the best action, now we use the updated policy to calculate the best action. This actor-critic is somewhat like the iterative-optimization methods seen in many math problems.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>To stabilize the training, now we tend to use the advantage function to replace the Q value.</p>
</div>
</div>
<p>PPO is an algorithm based on the actor-critic method, and it is to clip the ratio which indicates the difference of policy to [<img src="https://latex.codecogs.com/png.latex?1-%5Cepsilon">, <img src="https://latex.codecogs.com/png.latex?1+%5Cepsilon">].</p>
<p>To do so, we just need to the change the policy objection function (with advantage function) from <img src="https://latex.codecogs.com/png.latex?%0AJ(%5Ctheta)%20=%20%5Cmathbb%7BE%7D_t%5Cleft%5B%20%5Clog%5Cpi_%5Ctheta%20(a_t%5Cmid%20s_t)*A_t%20%5Cright%5D%0A"></p>
<p>to <img src="https://latex.codecogs.com/png.latex?%0AJ(%5Ctheta)=%5Chat%7B%5Cmathbb%7BE%7D%7D_t%5Cleft%5B%5Cmin%20%5Cleft(r_t(%5Ctheta)%20%5Chat%7BA%7D_t,%20%5Coperatorname%7Bclip%7D%5Cleft(r_t(%5Ctheta),%201-%5Cepsilon,%201+%5Cepsilon%5Cright)%20%5Chat%7BA%7D_t%5Cright)%5Cright%5D%0A"></p>
<p>where the ratio is <img src="https://latex.codecogs.com/png.latex?%0Ar_t(%5Ctheta)=%5Cfrac%7B%5Cpi_%5Ctheta%5Cleft(a_t%20%5Cmid%20s_t%5Cright)%7D%7B%5Cpi_%7B%5Ctheta_%7B%5Ctext%20%7Bold%20%7D%7D%7D%5Cleft(a_t%20%5Cmid%20s_t%5Cright)%7D.%0A"></p>
<p>Now, we use a PPO implementation to better study the algorithm above. The <a href="https://github.com/vwxyzjn/cleanrl/blob/master/cleanrl/ppo.py">full code implementation can be found here</a>. There is also <a href="https://iclr-blog-track.github.io/2022/03/25/ppo-implementation-details/">another wonderful post about PPO implementation</a>. Let‚Äôs study the code now.</p>
<section id="define-both-the-actor-and-critic" class="level4">
<h4 class="anchored" data-anchor-id="define-both-the-actor-and-critic">Define both the actor and critic</h4>
<p>We usually define the network directly!</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">class</span> Agent(nn.Module):</span>
<span id="cb6-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, envs):</span>
<span id="cb6-3">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">super</span>().<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>()</span>
<span id="cb6-4">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.critic <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Sequential(</span>
<span id="cb6-5">            layer_init(nn.Linear(np.array(envs.single_observation_space.shape).prod(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>)),</span>
<span id="cb6-6">            nn.Tanh(),</span>
<span id="cb6-7">            layer_init(nn.Linear(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>)),</span>
<span id="cb6-8">            nn.Tanh(),</span>
<span id="cb6-9">            layer_init(nn.Linear(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>), std<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.0</span>),</span>
<span id="cb6-10">        )</span>
<span id="cb6-11">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.actor <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Sequential(</span>
<span id="cb6-12">            layer_init(nn.Linear(np.array(envs.single_observation_space.shape).prod(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>)),</span>
<span id="cb6-13">            nn.Tanh(),</span>
<span id="cb6-14">            layer_init(nn.Linear(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>)),</span>
<span id="cb6-15">            nn.Tanh(),</span>
<span id="cb6-16">            layer_init(nn.Linear(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">64</span>, envs.single_action_space.n), std<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>),</span>
<span id="cb6-17">        )</span>
<span id="cb6-18"></span>
<span id="cb6-19">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> get_value(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x):</span>
<span id="cb6-20">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.critic(x)</span>
<span id="cb6-21"></span>
<span id="cb6-22">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> get_action_and_value(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x, action<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>):</span>
<span id="cb6-23">        logits <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.actor(x)</span>
<span id="cb6-24">        probs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Categorical(logits<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>logits)</span>
<span id="cb6-25">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> action <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">is</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>:</span>
<span id="cb6-26">            action <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> probs.sample()</span>
<span id="cb6-27">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> action, probs.log_prob(action), probs.entropy(), <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.critic(x)</span></code></pre></div>
<p>Note that we don‚Äôt have q value here since the PPO uses the advantage value which means we don‚Äôt need the Q value anymore! And you may observe that critic output is a single dim value.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In pytorch, the forward process is not necessarily defined in <code>forward()</code> function. We often use it since it has customization so that <code>model(**params)</code> is equal to <code>model.forward(**params)</code>.</p>
</div>
</div>
</section>
<section id="deal-with-the-advantage-values" class="level4">
<h4 class="anchored" data-anchor-id="deal-with-the-advantage-values">Deal with the advantage values</h4>
<p>The action value is simply as <img src="https://latex.codecogs.com/png.latex?%0AA(s_t,%20a_t)%20=%20Q(s_t,%20a_t)%20-%20V(s_t)%20=%20r%20+%20%5Cgamma%20V(s_%7Bt+1%7D)%20-%20V(s)%0A"> Here, we use <img src="https://latex.codecogs.com/png.latex?r%20+%20%5Cgamma%20V(s_%7Bt+1%7D)"> to appriximate the <img src="https://latex.codecogs.com/png.latex?Q"> value, but recall in the DQN algorithm, we use it as well!</p>
</section>
</section>
<section id="apply-ppo-to-llm" class="level3">
<h3 class="anchored" data-anchor-id="apply-ppo-to-llm">Apply PPO to LLM</h3>
<p>Now, we discuss the pivotal topic of this blog. How to consider the LLM training as a PPO.</p>
<p>We use the concept of RL, and explain how LLM can be used here.</p>
<ul>
<li><strong>environment</strong>: The language world, when you output a new word, it will be added as the context of the conversation. The observation/state is the existing generation and the initial language;</li>
<li><strong>state</strong>: The existing generation and the initial language;</li>
<li><strong>agent</strong>: The LLM model it self. We have <code>LLM(curr_words) = next_token</code>. Here <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta"> = LLM;</li>
<li><strong>reward</strong>: Can be customized, and we usually choose to add a linear layer (two-heads output) to the last embedding layer of the LLM as the reward function.</li>
</ul>
<p>The step of the PPO can be formulated as the following:</p>
<ol type="1">
<li>Given the preference pair (<img src="https://latex.codecogs.com/png.latex?y_%7BY%7D">, <img src="https://latex.codecogs.com/png.latex?y_%7BN%7D">), we train a reward model. The reward model can be trained using the following loss: <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_R%5Cleft(r_%5Cphi,%20%5Cmathcal%7BD%7D%5Cright)=-%5Cmathbb%7BE%7D_%7B%5Cleft(x,%20y_Y,%20y_N%5Cright)%20%5Csim%20%5Cmathcal%7BD%7D%7D%5Cleft%5B%5Clog%20%5Csigma%5Cleft(r_%5Cphi%5Cleft(x,%20y_Y%5Cright)-r_%5Cphi%5Cleft(x,%20y_N%5Cright)%5Cright)%5Cright%5D%0A"></li>
<li>After the have the reward function, we freeze the parameters <img src="https://latex.codecogs.com/png.latex?%5Cphi"> and train the <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> by optimization of <img src="https://latex.codecogs.com/png.latex?%0A%5Cmax%20_%7B%5Cpi_%5Ctheta%7D%20%5Cmathbb%7BE%7D_%7Bx%20%5Csim%20%5Cmathcal%7BD%7D,%20y%20%5Csim%20%5Cpi_%5Ctheta(y%20%5Cmid%20x)%7D%5Cleft%5Br_%5Cphi(x,%20y)%5Cright%5D-%5Cbeta%20%5Cmathbb%7BD%7D_%7B%5Cmathrm%7BKL%7D%7D%5Cleft%5B%5Cpi_%5Ctheta(y%20%5Cmid%20x)%20%5C%7C%20%5Cpi_%7B%5Cmathrm%7Bref%7D%7D(y%20%5Cmid%20x)%5Cright%5D%0A"></li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The here should be perceived as a probability function. Thus, <img src="https://latex.codecogs.com/png.latex?%5Cpi_%5Ctheta(y%7Cx)"> will output a probability!</p>
<p>Actually, in the case of LLM, we have <img src="https://latex.codecogs.com/png.latex?%0A%5Cpi_%5Ctheta(y%7Cx)%20=%20p(y%7Cx;%20%5Ctext%7BLLM%7D)%20=%20p(y_%7B0%7D%7Cx,%20y)%5Cprod_%7Bi=1%7D%5ETp(y_%7B1%7D%7Cx,%20y_%7B0,...,i-1%7D;%20%5Ctext%7BLLM%7D)%0A"></p>
</div>
</div>
</section>
<section id="dpo" class="level3">
<h3 class="anchored" data-anchor-id="dpo">DPO</h3>
<p>DPO is another method inspired by the limitation of the PPO. In the case of direct preference of choosing from two results. The human preference distribution <img src="https://latex.codecogs.com/png.latex?p%5E*"> can be expressed with reward function: <img src="https://latex.codecogs.com/png.latex?%0Ap%5E*%5Cleft(y_1%20%5Csucc%20y_2%20%5Cmid%20x%5Cright)=%5Cfrac%7B%5Cexp%20%5Cleft(r%5E*%5Cleft(x,%20y_1%5Cright)%5Cright)%7D%7B%5Cexp%20%5Cleft(r%5E*%5Cleft(x,%20y_1%5Cright)%5Cright)+%5Cexp%20%5Cleft(r%5E*%5Cleft(x,%20y_2%5Cright)%5Cright)%7D%0A"></p>
<p>The DPO paper indicate that we can express the probability under the policy <img src="https://latex.codecogs.com/png.latex?%5Cpi%5E*"> with</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ap%5E*%5Cleft(y_1%20%5Csucc%20y_2%20%5Cmid%20x%5Cright)=%5Cfrac%7B1%7D%7B1+%5Cexp%20%5Cleft(%5Cbeta%20%5Clog%20%5Cfrac%7B%5Cpi%5E*%5Cleft(y_2%20%5Cmid%20x%5Cright)%7D%7B%5Cpi_%7B%5Cmathrm%7Bref%7D%7D%5Cleft(y_2%20%5Cmid%20x%5Cright)%7D-%5Cbeta%20%5Clog%20%5Cfrac%7B%5Cpi%5E*%5Cleft(y_1%20%5Cmid%20x%5Cright)%7D%7B%5Cpi_%7B%5Cmathrm%7Bref%7D%7D%5Cleft(y_1%20%5Cmid%20x%5Cright)%7D%5Cright)%7D%0A"></p>
<p>Therefore, we don‚Äôt need the real PPO now. And we just need to do something like a SFT with a different loss function: <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_%7B%5Cmathrm%7BDPO%7D%7D%5Cleft(%5Cpi_%5Ctheta%20;%20%5Cpi_%7B%5Cmathrm%7Bref%7D%7D%5Cright)=-%5Cmathbb%7BE%7D_%7B%5Cleft(x,%20y_w,%20y_l%5Cright)%20%5Csim%20%5Cmathcal%7BD%7D%7D%5Cleft%5B%5Clog%20%5Csigma%5Cleft(%5Cbeta%20%5Clog%20%5Cfrac%7B%5Cpi_%5Ctheta%5Cleft(y_w%20%5Cmid%20x%5Cright)%7D%7B%5Cpi_%7B%5Ctext%20%7Bref%20%7D%7D%5Cleft(y_w%20%5Cmid%20x%5Cright)%7D-%5Cbeta%20%5Clog%20%5Cfrac%7B%5Cpi_%5Ctheta%5Cleft(y_l%20%5Cmid%20x%5Cright)%7D%7B%5Cpi_%7B%5Ctext%20%7Bref%20%7D%7D%5Cleft(y_l%20%5Cmid%20x%5Cright)%7D%5Cright)%5Cright%5D%20.%0A"></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>During training, the <img src="https://latex.codecogs.com/png.latex?%5Cpi_%7Bref%7D"> is freezed!</p>
</div>
</div>


</section>
</section>

 ]]></description>
  <category>Large Language Models</category>
  <guid>https://alexchen4ai.github.io/blog/notes/Large Language Model/rl_llm.html</guid>
  <pubDate>Thu, 15 Feb 2024 08:00:00 GMT</pubDate>
</item>
</channel>
</rss>
