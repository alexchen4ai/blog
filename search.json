[
  {
    "objectID": "hello.html",
    "href": "hello.html",
    "title": "Quarto Basics",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure¬†1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure¬†1: A line plot on a polar axis\n\n\n\n\n\nOf course, we can also write equations here freely.\n\\[\\hat{m} = (w_1 A_1 + w_2 A_2 + \\dots + w_N A_N) (w_1 B_1 + w_2 B_2 + \\dots + w_N B_N).\\]"
  },
  {
    "objectID": "notes/Large Language Model/rl_llm.html",
    "href": "notes/Large Language Model/rl_llm.html",
    "title": "Reinforcement learning for large language model",
    "section": "",
    "text": "Tip\n\n\n\nReinforment is a common technique, which can be applied to the large language model area.",
    "crumbs": [
      "Home",
      "üó£Ô∏è **Large language models**",
      "Reinforcement learning for large language model"
    ]
  },
  {
    "objectID": "notes/Large Language Model/rl_llm.html#background-of-reinforcement-learning",
    "href": "notes/Large Language Model/rl_llm.html#background-of-reinforcement-learning",
    "title": "Reinforcement learning for large language model",
    "section": "Background of reinforcement learning",
    "text": "Background of reinforcement learning\nIn the first section, we will review the fundamental concept of the reinforcement learning. The fundamental part of the reinforcement learning includes the agent and environment. The process is as the following:\n\n\n\nAt each iteration step, we have the state of the environement marked as \\(S\\), the action \\(A\\) and the reward \\(R\\). Below, we list the step at the time step \\(t\\):\n\nBased on the current state \\(S_t\\), the agent make the action \\(A_t\\);\nThe environment react to the action and transit to the state \\(S_{t+1}\\) and reward \\(R_{t+1}\\).\n\nTherefore, related to each action, we will have a state of \\(S_t, A_t, S_{t+1}, R_{t+1}\\). And these four variables will be the critical data used for the reinforcement learning! Now, let me introduce more about the glossary of the reinforcement learning terms.\n\nMarkov chain: The Markov chain means that the action taken by the agent is only dependent on the most recent state/present state, and is independent of past states.\nObservation/State: The state is the complete description while the observation is just the partial description. The partial description means part of the state.\npolicy: The policy is usually denoted as \\(\\pi\\) and it is used to decide which action \\(a\\) to take. According to the Markov chain, we have \\(\\pi(s)=a\\).\nreward: Reward is the value that we can get immediately after we take a new action. For example, in cartpole example, we get every positive feedback if the cartpole doesn‚Äôt fail.\nValue: The value function to calculate the discounted sum of all future rewards! Thus, the values are different from the reward.\n\nThese are some basic concepts in the reinforcement learning! We will introduce more advanced concept along with more topics involved below. We revisit the fundamental part of the RL: The agent can repeated to take actions and get feedback (rewards/values) from the environment so that it can update the agent itself to behave better to get best reward or values. The deep learning and pytorch is not designed for the RL, and RL is more a mathematically which may not naturally suited for the deep learning. Rather, we design some equation to apply the deep learning. Thus, when we design the RL, we need to think from the fundamental math, and deep learning is just a method to solve a math problem.",
    "crumbs": [
      "Home",
      "üó£Ô∏è **Large language models**",
      "Reinforcement learning for large language model"
    ]
  },
  {
    "objectID": "notes/Large Language Model/rl_llm.html#the-classification-of-rl",
    "href": "notes/Large Language Model/rl_llm.html#the-classification-of-rl",
    "title": "Reinforcement learning for large language model",
    "section": "The classification of RL",
    "text": "The classification of RL\nTo solve the RL problem, we have various methods! The detailed is concluded in the figure below. We will study more about the policy based method, the value based method. And for SOTA, the LLM usuaully use a combined method. When we consider how to train the RL, we should first think about how to use the pretrained model. We wish the model to guide us to get the best action to take at every step! Thus, we need a great policy \\(\\pi^*\\)!.\n\n\n\n\nThe value based method\nThe famous \\(Q\\) learning is a typical value-based method. The original paper can be accessed here. The \\(Q\\) is the abbreviate of quality. The value based method has two submethods called the state-value function and the action-value function. Usually, we use \\(V\\) to represent the value, which is\n\\[\nV_{\\pi}(s) = \\mathbb{E}_{\\pi}\\left[ R_{t+1}+\\gamma R_{t+2} + \\gamma^2R_{t+3}+... | S_t=s \\right]\n\\]\nLet me clarify the equation above in a probability. The \\(\\pi\\) is like a distribution, and we may express the value as\n\\[\nV_{\\pi}(s) = \\mathbb{E}_{\\tau\\sim\\pi}\\left[ R_{t+1}+\\gamma R_{t+2} + \\gamma^2R_{t+3}+... | S_t=s \\right]\n\\]\nsince we have \\(a\\sim \\pi(s)\\). And \\(a\\) is directly relevant to the trajectory \\(\\tau\\) which can be used for comprehensive rewards. Now, we have known the value function, this is a value that can evaluate the current confidence to get the best reward based on the current state! Another better and granular method is not just the current state, but also the action. And we introduce the \\(Q\\) value. However, fundamentally, we have \\(Q\\) and \\(V\\) to express the same meaning, the confidence or the estimated quality of the current condition. The only difference is that the \\(Q\\) function also count in the actions.\nThe comparison would be \\(V_\\pi (s)=\\mathbb{E}_\\pi [G_t|S_t=s]\\) vs.¬†\\(Q_{\\pi}(s, a)=\\mathbb{E_\\pi}[G_t|S_t=s, A_t=a]\\). The \\(G_t\\) here represent the ending state. Then, as stated above how do we get the best policy? We can use\n\\[\n\\pi^* = \\text{arg}\\max_a Q^*(s, a)\n\\]\nTo simulate the RL, we usually need to simulate the whole episode, like a cartpole example would continue until it fails. However, there are ways to simplify the process by Bellman equation: \\[\nV_\\pi(s) = \\mathbb{E}_{\\pi} [R_{t+1}+\\gamma * V_{\\pi}(S_{t+1})|S_t=s].\n\\] And we can update the value function by Monte Carlo or the Temporary Difference method. The \\(Q\\) learning is an off-policy (when updating the value function choose a different way to sample the action) value-based method that uses a TD approach to train its action-value function.\nBefore move on, we explain the off-policy. In RL, we usually use \\(\\epsilon\\) greedy policy to choose the actions. That is for a given state \\(s\\), we take the action by sample \\(p\\in [0,1]\\): \\[\nf(x) =\n\\begin{cases}\n\\pi^*(s) & \\text{$p\\leq\\epsilon$}, \\\\\n\\text{random action} & \\text{otherwise}.\n\\end{cases}\n\\] This is a combination of exploration and eploitation. And each time, when we train the \\(Q\\) function, we update it like \\[\nQ(S_t, A_t) \\leftarrow Q(S_t, A_t) +\\alpha (R_{t+1}+\\gamma \\max_a Q(S_{t+1}, a) -Q(S_t, A_t))\n\\tag{1}\\]\nFor certain case with finite number of state and actions, we can easily use a table to record the \\(Q\\) function. However, for some infinite number of states and actions, we need more complicated expression. For example, a math function, and abstract that function we can get the deep neural network \\(Q\\). This is how we can infer the DQN, a nature paper. This basically tell us the value of \\(Q_\\theta (s, a)\\).\nA DQN algorithm is:\n\nInitialize replay memory \\(D\\) to capacity \\(N\\)\nInitialize action-value function \\(Q\\) with random weights \\(\\theta\\)\nInitialize target action-value function \\(\\hat{Q}\\) with weights \\(\\theta^{-} = \\theta\\)\nFor episode = \\(1, M\\) do\n\nInitialize sequence \\(s_1 = \\{x_1\\}\\) and preprocessed sequence \\(\\phi_1 = \\phi(s_1)\\)\nFor \\(t = 1, T\\) do\n\nWith probability \\(\\varepsilon\\) select a random action \\(a_t\\) otherwise select \\(a_t = \\text{argmax}_a Q(\\phi(s_t), a; \\theta)\\)\nExecute action \\(a_t\\) in emulator and observe reward \\(r_t\\) and image \\(x_{t+1}\\)\nSet \\(s_{t+1} = s_t, a_t, x_{t+1}\\) and preprocess \\(\\phi_{t+1} = \\phi(s_{t+1})\\)\nStore transition \\((\\phi_t, a_t, r_t, \\phi_{t+1})\\) in \\(D\\)\nSample random minibatch of transitions \\((\\phi_j, a_j, r_j, \\phi_{j+1})\\) from \\(D\\)\nSet \\(y_j = \\left\\{\\begin{array}{ll}\nr_j & \\text{if episode terminates at step } j+1 \\\\\nr_j + \\gamma \\max_{a'} \\hat{Q}(\\phi_{j+1}, a'; \\theta^{-}) & \\text{otherwise}\n\\end{array}\\right.\\)\nPerform a gradient descent step on \\((y_j - Q(\\phi_j, a_j; \\theta))^2\\) with respect to the network parameters \\(\\theta\\)\nEvery \\(C\\) steps reset \\(\\hat{Q} = Q\\)\n\n\n\nHere \\(\\phi\\) represent some feature encoder! For example, if the state can be represented as image. Then, \\(\\phi\\) is something like the RGB value extractor. From the DQN algorithm above, we notice that the gradient descent is applied on the loss term of \\[\n(y_j - Q(\\phi_j, a_j; \\theta))^2\n\\tag{2}\\]\nThis is to make the learned \\(Q\\) function to approximate the value of the predicted \\(Q\\) value. If we revisit the Equation¬†1, we notice that the original Q value update is to directly update the \\(Q(S_t, A_t)\\), and the goal is to reduce the difference between \\(R_{t+1}+\\gamma \\max_a Q(S_{t+1}, a)\\) and the \\(Q(S_t, A_t)\\). In the context of the DQN, we can direcly construct the Equation¬†2 for it! One notation here is that in the Equation¬†1, we set the \\(R_{t+1}\\), with the same subscript as \\(S_{t+1}\\), but in the algorithm described above, we have it expressed as \\(r_{j}\\) with the -1 subscript compared to \\(\\phi_{j+1}\\). However, the two terms are the same, we use \\(t\\) since it represents the time step. For the use of \\(j\\), it is one step of generated rewards! It is just different notation.\n\n\n\n\n\n\nTip\n\n\n\nWhy do we use Equation¬†2? Q is the quality value, and it is used to estimate the total expected rewards based on the current state and the action. Suppose we already have the best \\(Q\\), then \\(Q(\\phi_j, a_j)\\) should be equal to the reward after we take the action \\(a_j\\), and then based on the state \\(\\phi_{j+1}\\), the best rewards we can expect, and we use a greedy algorithm here.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIt is always good to visit the code implementation to make sure you understand the detail.\n\n\nWe can study a DQN example from the atari simulation, and the full github code can be accessed there. Now, we will combine the algorithm and the code to introduce more about the DQN.\nFirstly, we need to have data generation process, and we can use\nnext_obs, rewards, terminations, truncations, infos = envs.step(actions)\nto get the variables \\(R, S, A\\) and so on. And we save the generated data to the replay\nrb.add(obs, real_next_obs, actions, rewards, terminations, infos)\nAnd the update process is like\ndata = rb.sample(args.batch_size)\nwith torch.no_grad():\n   target_max, _ = target_network(data.next_observations).max(dim=1)\n   # data.dones is 0 or 1.\n   td_target = data.rewards.flatten() + args.gamma * target_max * (1 - data.dones.flatten())\nold_val = q_network(data.observations).gather(1, data.actions).squeeze()\nloss = F.mse_loss(td_target, old_val)\n\n\nThe policy based method\nWe can also train the policy directly \\(\\pi_\\theta\\). It is more intuitive. Compared to the value-based method, it has pros and cons.\nFor pros: (a) Can explore stochastic polify, no need for the exploration and exploitation effort; (b) More effective in high-dimensional action space, especially the continuous actions spaces; (c) Better convergence properties, the curve is smoother.\nFor the cons: (a) Often get suboptimal result; (b) Take longer time to train; (c) Policy gradient have high variance (The policy gradient in different step has really different result).\n\n\n\n\n\n\nTip\n\n\n\nNote that Q learning method needs the argmax to get the best action. And if the action is a continuous space, we need to do some pretty complicated optimization to get the result!\n\n\nNote that \\(\\pi_\\theta (s) = \\mathbb{P}(A|s;\\theta)\\). Thus, the training basically becomes that when we have postive reward, we should increase the proability of the state and action pair. Otherwise, decrease it. The objective function is still the total rewards! \\[\nJ(\\theta) = \\mathbb{E}_{\\tau\\sim \\pi}[R(\\tau)],\n\\] where \\(\\tau\\) is a trajectory (a whole simulation process). We already have a theorem to update the policy:\n\\[\n\\nabla_\\theta J(\\theta)=\\mathbb{E}_{\\pi_\\theta}\\left[\\nabla_\\theta \\log \\pi_\\theta\\left(a_t \\mid s_t\\right) R(\\tau)\\right]\n\\]\nwhich is valid for any differentiable policy and for any policy objective function! To better understand the process, we introduce the Monte Carlo Reinforce. In a loop:\n\nUse the policy \\(\\pi_\\theta\\) to collect an episode \\(\\tau\\)\nUse the episode to estimate the gradient \\(\\hat{g}=\\nabla_\\theta J(\\theta)\\) \\[\n\\nabla_\\theta J(\\theta) \\approx \\hat{g}=\\sum_{t=0} \\nabla_\\theta \\log \\pi_\\theta\\left(a_t \\mid s_t\\right) R(\\tau)\n\\]\nUpdate the weights of the policy: \\(\\theta \\leftarrow \\theta+\\alpha \\hat{g}\\). (Gradient ascent)\n\nAlternatively, we can collect multiple trajectories (helpful to mitigate the variance), and the gradient becomes \\[\n\\nabla_\\theta J(\\theta) \\approx \\hat{g}=\\frac{1}{m}\\sum_{i=1}^m\\sum_{t=0} \\nabla_\\theta \\log \\pi_\\theta\\left(a_t^{(i)} \\mid s_t^{(i)}\\right) R(\\tau^{(i)}).\n\\]\n\n\n\n\n\n\nTip\n\n\n\nWe can treat the \\(\\nabla_\\theta \\log\\pi_\\theta(a_t\\mid s_t)\\) is the direction of the steeppest increase of the log probability of selected action based on the \\(s_t\\). This is because that we wish to maximize the objective here (rewards).\n\n\nFor the derivation of the policy gradient theorem, check the following:\n\nTheorem 1 (policy-gradient-theorem) The derivation of the policy gradient theorem is as the following:\n\\[\n\\begin{aligned}\n\\nabla_\\theta J(\\theta)  &= \\mathbb{E}_{\\tau\\sim \\pi}[R(\\tau)] \\\\\n   &= \\nabla_\\theta \\sum_{\\tau}P(\\tau;\\theta)R(\\tau) \\\\\n   &= \\sum_{\\tau} \\nabla_\\theta P(\\tau;\\theta)R(\\tau) \\\\\n   &= \\sum_{\\tau} P(\\tau;\\theta) \\frac{\\nabla_\\theta P(\\tau;\\theta)}{P(\\tau;\\theta)}R(\\tau) \\\\\n   &= \\sum_{\\tau} P(\\tau;\\theta) \\nabla_\\theta \\log P(\\tau;\\theta)R(\\tau) \\\\\n   &= \\sum_{\\tau} P(\\tau;\\theta) \\nabla_\\theta\\log [\\phi(s_0)\\prod_{t=0}^T P(s_{t+1}|s_t, a_t)\\pi_\\theta (a_t\\mid s_t)] R(\\tau)\\\\\n   &= \\sum_{\\tau} P(\\tau;\\theta) \\nabla_\\theta\\left[\\log\\phi(s_0) + \\log\\sum_{t=0}^T P(s_{t+1}|s_t, a_t) +\\log\\sum_{t=0}^T\\pi_\\theta (a_t\\mid s_t)\\right] R(\\tau)\\\\\n   &= \\sum_{\\tau} P(\\tau;\\theta) \\nabla_\\theta\\left[\\log\\sum_{t=0}^T\\pi_\\theta (a_t\\mid s_t)\\right] R(\\tau).\n\\end{aligned}\n\\tag{3}\\]\n\nFor the code part, using the cartpole as an example, the policy framework would be\nclass Policy(nn.Module):\n    def __init__(self, s_size, a_size, h_size):\n        super(Policy, self).__init__()\n        self.fc1 = nn.Linear(s_size, h_size)\n        self.fc2 = nn.Linear(h_size, a_size)\n\n    def forward(self, x):\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return F.softmax(x, dim=1)\n\n    def act(self, state):\n        state = torch.from_numpy(state).float().unsqueeze(0).to(device)\n        probs = self.forward(state).cpu()\n        m = Categorical(probs)\n        action = np.argmax(m)\n        return action.item(), m.log_prob(action)\nNote that we need to use the Categorical from torch.distributions to enable the backpropagation. The reinforce process can be constructed according to the reinfoce algorithm introduced above.\ndef reinforce(policy, optimizer, n_training_episodes, max_t, gamma, print_every):\n    scores_deque = deque(maxlen=100)\n    scores = []\n    for i_episode in range(1, n_training_episodes + 1):\n        saved_log_probs = []\n        rewards = []\n        state = env.reset()\n        for t in range(max_t):\n            action, log_prob = policy.act(state)\n            saved_log_probs.append(log_prob)\n            state, reward, done, _ = env.step(action)\n            rewards.append(reward)\n            if done:\n                break\n        scores_deque.append(sum(rewards))\n        scores.append(sum(rewards))\n\n        returns = deque(maxlen=max_t)\n        n_steps = len(rewards)\n        \n        for t in range(n_steps)[::-1]:\n            disc_return_t = returns[0] if len(returns) &gt; 0 else 0\n            returns.appendleft(gamma * disc_return_t + rewards[t])\n\n        ## standardization of the returns is employed to make training more stable\n        eps = np.finfo(np.float32).eps.item()\n\n        ## eps is the smallest representable float, which is\n        # added to the standard deviation of the returns to avoid numerical instabilities\n        returns = torch.tensor(returns)\n        returns = (returns - returns.mean()) / (returns.std() + eps)\n\n        policy_loss = []\n        for log_prob, disc_return in zip(saved_log_probs, returns):\n            policy_loss.append(-log_prob * disc_return)\n        policy_loss = torch.cat(policy_loss).sum()\n\n        optimizer.zero_grad()\n        policy_loss.backward()\n        optimizer.step()\n\n        if i_episode % print_every == 0:\n            print(\"Episode {}\\tAverage Score: {:.2f}\".format(i_episode, np.mean(scores_deque)))\n    return scores\n\n\nThe actor-critic method and PPO\n\n\n\n\n\n\nTip\n\n\n\nSOTA, we usually use a mixed method containing both policy based and value based methods.\n\n\nThe motivation of the actor-critic method is to lower the variation of the policy method. We can use a large number of the trajectories but it is not efficient. Therefore, we choose a new method called actor-critic method. That is to say, instead of giving rewards/feedback to the policy (actor) after many trajectories, we can use critic to give instant feedback to evaluate the actions taken by the policy. Now, we have two network to train:\n\nA policy function with parameters \\(\\pi_\\theta(s)\\);\nA value function with parameters \\({q}_w(s, a)\\)\n\nThis is a combined methods of the policy-based and value-based methods. For one step of time \\(t\\)\n\nAt time step \\(t\\), we have the state \\(s_t\\);\nWe have the policy \\(\\pi_\\theta(s_t) = a_t\\);\nNow, we can compute the Q-value by the value function directly as \\(Q_t={q}_w(s, a)\\);\nExecute the action \\(a_t\\) and get the new state \\(s_{t+1}\\) and new reward \\(r_{t+1}\\).\nUpdate the policy parameters using the Q value;\nUsing the updated parameters to get the next action \\(a_{t+1}\\), and use the new action to update critic parameters.\n\n\n\n\n\n\n\nTip\n\n\n\nIn policy based function, Equation¬†3 needs to use \\(R(\\tau)\\), and \\(R(\\tau)\\) is obtained by iterative experiments. Now, we can use Q value since they represent the same meaning. Also, when we update the Q parameters, we use argmax to get the best action, now we use the updated policy to calculate the best action. This actor-critic is somewhat like the iterative-optimization methods seen in many math problems.\n\n\n\n\n\n\n\n\nTip\n\n\n\nTo stabilize the training, now we tend to use the advantage function to replace the Q value.\n\n\nPPO is an algorithm based on the actor-critic method, and it is to clip the ratio which indicates the difference of policy to [\\(1-\\epsilon\\), \\(1+\\epsilon\\)].\nTo do so, we just need to the change the policy objection function (with advantage function) from \\[\nJ(\\theta) = \\mathbb{E}_t\\left[ \\log\\pi_\\theta (a_t\\mid s_t)*A_t \\right]\n\\]\nto \\[\nJ(\\theta)=\\hat{\\mathbb{E}}_t\\left[\\min \\left(r_t(\\theta) \\hat{A}_t, \\operatorname{clip}\\left(r_t(\\theta), 1-\\epsilon, 1+\\epsilon\\right) \\hat{A}_t\\right)\\right]\n\\]\nwhere the ratio is \\[\nr_t(\\theta)=\\frac{\\pi_\\theta\\left(a_t \\mid s_t\\right)}{\\pi_{\\theta_{\\text {old }}}\\left(a_t \\mid s_t\\right)}.\n\\]\nNow, we use a PPO implementation to better study the algorithm above. The full code implementation can be found here. There is also another wonderful post about PPO implementation. Let‚Äôs study the code now.\n\nDefine both the actor and critic\nWe usually define the network directly!\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.critic = nn.Sequential(\n            layer_init(nn.Linear(np.array(envs.single_observation_space.shape).prod(), 64)),\n            nn.Tanh(),\n            layer_init(nn.Linear(64, 64)),\n            nn.Tanh(),\n            layer_init(nn.Linear(64, 1), std=1.0),\n        )\n        self.actor = nn.Sequential(\n            layer_init(nn.Linear(np.array(envs.single_observation_space.shape).prod(), 64)),\n            nn.Tanh(),\n            layer_init(nn.Linear(64, 64)),\n            nn.Tanh(),\n            layer_init(nn.Linear(64, envs.single_action_space.n), std=0.01),\n        )\n\n    def get_value(self, x):\n        return self.critic(x)\n\n    def get_action_and_value(self, x, action=None):\n        logits = self.actor(x)\n        probs = Categorical(logits=logits)\n        if action is None:\n            action = probs.sample()\n        return action, probs.log_prob(action), probs.entropy(), self.critic(x)\nNote that we don‚Äôt have q value here since the PPO uses the advantage value which means we don‚Äôt need the Q value anymore! And you may observe that critic output is a single dim value.\n\n\n\n\n\n\nTip\n\n\n\nIn pytorch, the forward process is not necessarily defined in forward() function. We often use it since it has customization so that model(**params) is equal to model.forward(**params).\n\n\n\n\nDeal with the advantage values\nThe action value is simply as \\[\nA(s_t, a_t) = Q(s_t, a_t) - V(s_t) = r + \\gamma V(s_{t+1}) - V(s)\n\\] Here, we use \\(r + \\gamma V(s_{t+1})\\) to appriximate the \\(Q\\) value, but recall in the DQN algorithm, we use it as well!\n\n\n\nApply PPO to LLM\nNow, we discuss the pivotal topic of this blog. How to consider the LLM training as a PPO.\nWe use the concept of RL, and explain how LLM can be used here.\n\nenvironment: The language world, when you output a new word, it will be added as the context of the conversation. The observation/state is the existing generation and the initial language;\nstate: The existing generation and the initial language;\nagent: The LLM model it self. We have LLM(curr_words) = next_token. Here \\(\\pi_\\theta\\) = LLM;\nreward: Can be customized, and we usually choose to add a linear layer (two-heads output) to the last embedding layer of the LLM as the reward function.\n\nThe step of the PPO can be formulated as the following:\n\nGiven the preference pair (\\(y_{Y}\\), \\(y_{N}\\)), we train a reward model. The reward model can be trained using the following loss: \\[\n\\mathcal{L}_R\\left(r_\\phi, \\mathcal{D}\\right)=-\\mathbb{E}_{\\left(x, y_Y, y_N\\right) \\sim \\mathcal{D}}\\left[\\log \\sigma\\left(r_\\phi\\left(x, y_Y\\right)-r_\\phi\\left(x, y_N\\right)\\right)\\right]\n\\]\nAfter the have the reward function, we freeze the parameters \\(\\phi\\) and train the \\(\\theta\\) by optimization of \\[\n\\max _{\\pi_\\theta} \\mathbb{E}_{x \\sim \\mathcal{D}, y \\sim \\pi_\\theta(y \\mid x)}\\left[r_\\phi(x, y)\\right]-\\beta \\mathbb{D}_{\\mathrm{KL}}\\left[\\pi_\\theta(y \\mid x) \\| \\pi_{\\mathrm{ref}}(y \\mid x)\\right]\n\\]\n\n\n\n\n\n\n\nTip\n\n\n\nThe here should be perceived as a probability function. Thus, \\(\\pi_\\theta(y|x)\\) will output a probability!\nActually, in the case of LLM, we have \\[\n\\pi_\\theta(y|x) = p(y|x; \\text{LLM}) = p(y_{0}|x, y)\\prod_{i=1}^Tp(y_{1}|x, y_{0,...,i-1}; \\text{LLM})\n\\]\n\n\n\n\nDPO\nDPO is another method inspired by the limitation of the PPO. In the case of direct preference of choosing from two results. The human preference distribution \\(p^*\\) can be expressed with reward function: \\[\np^*\\left(y_1 \\succ y_2 \\mid x\\right)=\\frac{\\exp \\left(r^*\\left(x, y_1\\right)\\right)}{\\exp \\left(r^*\\left(x, y_1\\right)\\right)+\\exp \\left(r^*\\left(x, y_2\\right)\\right)}\n\\]\nThe DPO paper indicate that we can express the probability under the policy \\(\\pi^*\\) with\n\\[\np^*\\left(y_1 \\succ y_2 \\mid x\\right)=\\frac{1}{1+\\exp \\left(\\beta \\log \\frac{\\pi^*\\left(y_2 \\mid x\\right)}{\\pi_{\\mathrm{ref}}\\left(y_2 \\mid x\\right)}-\\beta \\log \\frac{\\pi^*\\left(y_1 \\mid x\\right)}{\\pi_{\\mathrm{ref}}\\left(y_1 \\mid x\\right)}\\right)}\n\\]\nTherefore, we don‚Äôt need the real PPO now. And we just need to do something like a SFT with a different loss function: \\[\n\\mathcal{L}_{\\mathrm{DPO}}\\left(\\pi_\\theta ; \\pi_{\\mathrm{ref}}\\right)=-\\mathbb{E}_{\\left(x, y_w, y_l\\right) \\sim \\mathcal{D}}\\left[\\log \\sigma\\left(\\beta \\log \\frac{\\pi_\\theta\\left(y_w \\mid x\\right)}{\\pi_{\\text {ref }}\\left(y_w \\mid x\\right)}-\\beta \\log \\frac{\\pi_\\theta\\left(y_l \\mid x\\right)}{\\pi_{\\text {ref }}\\left(y_l \\mid x\\right)}\\right)\\right] .\n\\]\n\n\n\n\n\n\nTip\n\n\n\nDuring training, the \\(\\pi_{ref}\\) is freezed!",
    "crumbs": [
      "Home",
      "üó£Ô∏è **Large language models**",
      "Reinforcement learning for large language model"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Alex Chen",
    "section": "",
    "text": "üëã Greetings! My name is Alex Chen, an AI researcher and startup founder in Silicon Valley. Previously, I pursued a PhD at Stanford University, delving into numerical simulation and artificial intelligence research. Now, I am building an AI agent UGC platform.\nIn this space, I aim to share my journey in academia and industry, providing insights into cutting-edge research and practical applications of AI and machine learning.\nIf you want to contact me, feel free to send a mail at this address.\n\nCredits:\n\nEmojis used in figures are designed by OpenMoji, the open-source emoji and icon project. License: CC BY-SA 4.0.\nVector icons are provided by Streamline (https://streamlinehq.com). License: CC BY-SA 4.0."
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Research notes",
    "section": "",
    "text": "Scalable diffusion models with transformers\n\n\n\n\n\n\nDiffusion Model\n\n\n\n\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\n\n\n\n\n\nReinforcement learning for large language model\n\n\n\n\n\n\nLarge Language Models\n\n\n\n\n\n\n\n\n\n19 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "chat_model.html",
    "href": "chat_model.html",
    "title": "Chat model demo",
    "section": "",
    "text": "The chat models are very different from the other models. We should spend more time for the data, especially during training.\n\nfrom transformers import AutoTokenizer\n\ntokenizer = AutoTokenizer.from_pretrained(\"mistralai/Mistral-7B-Instruct-v0.1\")\n\nchat = [\n    {\"role\": \"user\", \"content\": \"Hello, how are you?\"},\n    {\"role\": \"assistant\", \"content\": \"I'm doing great. How can I help you today?\"},\n    {\"role\": \"user\", \"content\": \"I'd like to show off how chat templating works!\"},\n]\n\ntokenizer.apply_chat_template(chat, tokenize=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"&lt;s&gt;[INST] Hello, how are you? [/INST]I'm doing great. How can I help you today?&lt;/s&gt; [INST] I'd like to show off how chat templating works! [/INST]\"\n\n\n\n# each model has different tokenizer! We can access the chat templates for each model\ntokenizer.chat_template\n\n\"{{ bos_token }}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if message['role'] == 'user' %}{{ '[INST] ' + message['content'] + ' [/INST]' }}{% elif message['role'] == 'assistant' %}{{ message['content'] + eos_token + ' ' }}{% else %}{{ raise_exception('Only user and assistant roles are supported!') }}{% endif %}{% endfor %}\"\n\n\n\n# During training, we should also use the chat templates to rearrange the dataset\nfrom transformers import AutoTokenizer\nfrom datasets import Dataset\n\ntokenizer = AutoTokenizer.from_pretrained(\"HuggingFaceH4/zephyr-7b-beta\")\n\nchat1 = [\n    {\"role\": \"user\", \"content\": \"Which is bigger, the moon or the sun?\"},\n    {\"role\": \"assistant\", \"content\": \"The sun.\"},\n]\nchat2 = [\n    {\"role\": \"user\", \"content\": \"Which is bigger, a virus or a bacterium?\"},\n    {\"role\": \"assistant\", \"content\": \"A bacterium.\"},\n]\n\ndataset = Dataset.from_dict({\"chat\": [chat1, chat2]})\ndataset = dataset.map(\n    lambda x: {\n        \"formatted_chat\": tokenizer.apply_chat_template(\n            x[\"chat\"], tokenize=False, add_generation_prompt=False\n        )\n    }\n)\nprint(dataset[\"formatted_chat\"][0])\n\n\n\nWe can also fill the missing tokens in the middle of the sentence. We just need to tell the language model the content before and after the missing part. And the model will handle the missing part automatically.\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\ntokenizer = AutoTokenizer.from_pretrained(\n    \"stabilityai/stable-code-3b\", trust_remote_code=True\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    \"stabilityai/stable-code-3b\",\n    trust_remote_code=True,\n    torch_dtype=\"auto\",\n    #   attn_implementation=\"flash_attention_2\",\n)\nmodel.cuda()\n\n# &lt;fim_prefix&gt; is the prefix code before the missiong part\n# &lt;fim_suffix&gt; is the suffix code after the missiong part\n# &lt;fim_middle&gt; is the missing part, and we add the token in the final part so that the model can predict it\ninputs = tokenizer(\n    \"&lt;fim_prefix&gt;def fib(n):&lt;fim_suffix&gt;    else:\\n        return fib(n - 2) + fib(n - 1)&lt;fim_middle&gt;\",\n    return_tensors=\"pt\",\n).to(model.device)\ntokens = model.generate(\n    **inputs,\n    max_new_tokens=48,\n    temperature=0.2,\n    do_sample=True,\n)\nprint(tokenizer.decode(tokens[0], skip_special_tokens=True))"
  },
  {
    "objectID": "chat_model.html#fill-in-middle-model",
    "href": "chat_model.html#fill-in-middle-model",
    "title": "Chat model demo",
    "section": "",
    "text": "We can also fill the missing tokens in the middle of the sentence. We just need to tell the language model the content before and after the missing part. And the model will handle the missing part automatically.\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\ntokenizer = AutoTokenizer.from_pretrained(\n    \"stabilityai/stable-code-3b\", trust_remote_code=True\n)\nmodel = AutoModelForCausalLM.from_pretrained(\n    \"stabilityai/stable-code-3b\",\n    trust_remote_code=True,\n    torch_dtype=\"auto\",\n    #   attn_implementation=\"flash_attention_2\",\n)\nmodel.cuda()\n\n# &lt;fim_prefix&gt; is the prefix code before the missiong part\n# &lt;fim_suffix&gt; is the suffix code after the missiong part\n# &lt;fim_middle&gt; is the missing part, and we add the token in the final part so that the model can predict it\ninputs = tokenizer(\n    \"&lt;fim_prefix&gt;def fib(n):&lt;fim_suffix&gt;    else:\\n        return fib(n - 2) + fib(n - 1)&lt;fim_middle&gt;\",\n    return_tensors=\"pt\",\n).to(model.device)\ntokens = model.generate(\n    **inputs,\n    max_new_tokens=48,\n    temperature=0.2,\n    do_sample=True,\n)\nprint(tokenizer.decode(tokens[0], skip_special_tokens=True))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Wei Chen",
    "section": "",
    "text": "I am inside a Hawaii cafe\n\n\n\n\n   \n\n\nGreetings! My name is Alex Chen, an AI researcher and startup founder in Silicon Valley. Previously, I pursued a PhD at Stanford University, delving into numerical simulation and artificial intelligence research.\nIn this space, I aim to share my journey in academia and industry, providing insights into cutting-edge research and practical applications of AI and machine learning.\n\nFeel free to connect with me:\n\nEmail: weichen6@stanford.edu\nCheck out my startup: AI Tools by Nexa"
  },
  {
    "objectID": "notes/Diffusion Model/sd.html",
    "href": "notes/Diffusion Model/sd.html",
    "title": "Scalable diffusion models with transformers",
    "section": "",
    "text": "Tip\n\n\n\nA text to image generation model from the diffusion architecture.\n\n\nüìù Paper: https://arxiv.org/abs/2212.09748",
    "crumbs": [
      "Home",
      "üí° **Diffusion models**",
      "Scalable diffusion models with transformers"
    ]
  }
]